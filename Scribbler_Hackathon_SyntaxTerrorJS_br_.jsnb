{
  "metadata": {
    "name": "Scribbler_Hackathon_SyntaxTerrorJS<br>",
    "language_info": {
      "name": "JavaScipt",
      "version": "8.0"
    }
  },
  "jsnbversion": "v0.1",
  "cells": [
    {
      "code": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Lattice Boltzman Fluid Simulator</title>\n    <link href=\"https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap\" rel=\"stylesheet\">\n    <style>\n        body {\n            margin: 0;\n            font-family: 'Roboto', sans-serif;\n            background-color: #121212;\n            color: #e0e0e0;\n        }\n        .container {\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n            justify-content: center;\n            height: 30vh;\n        }\n        .header {\n            margin-bottom: 20px;\n        }\n        h1 {\n            font-size: 2rem;\n            font-weight: 700;\n        }\n        .controls {\n            display: flex;\n            justify-content: center;\n            gap: 20px;\n            margin-bottom: 20px;\n            flex-wrap: wrap;  /* Allows wrapping */\n        }\n        .controls label {\n            font-weight: 500;\n        }\n        .controls select, .controls input {\n            background-color: #1e1e1e;\n            color: #e0e0e0;\n            border: 1px solid #333;\n            padding: 5px 10px;\n            border-radius: 5px;\n        }\n        button {\n            background-color: #333;\n            color: #e0e0e0;\n            padding: 10px 20px;\n            border: none;\n            border-radius: 5px;\n            cursor: pointer;\n        }\n        button:hover {\n            background-color: #444;\n        }\n        #projectCanvas {\n            width: 100%;\n            max-width: 100%;\n            height: 100%;\n            background-color: #000;\n            display: block;\n            margin: 0 auto;\n        }\n        .warning {\n            color: #ffcc00;\n            font-size: 0.9rem;\n            margin-top: 10px;\n            text-align: center;\n        }\n        button:disabled {\n            background-color: #555;\n            cursor: not-allowed;\n        }\n        .multiSimControls {\n            display: none;\n            flex-direction: column;\n            gap: 10px;\n            margin-top: 20px;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"header\">\n            <h1>Lattice Boltzman Fluid Simulator</h1>\n        </div>\n        <div class=\"controls\">\n            <label for=\"plotOptions\">Plot: \n                <select id=\"plotOptions\">\n                    <option value=\"curl\">Curl</option>\n                    <option value=\"rho\">Density</option>\n                    <option value=\"speed\">Speed</option>\n                    <option value=\"vx\">X Velocity</option>\n                    <option value=\"vy\">Y Velocity</option>\n                </select>\n            </label>\n            <label for=\"viscositySlider\">Viscosity: \n                <input type=\"range\" id=\"viscositySlider\" min=\"0.003\" max=\"0.1\" step=\"0.001\" value=\"0.015\">\n            </label>\n            <!-- Checkbox for multi-simulation -->\n            <label for=\"multiSimCheckbox\">\n                <input type=\"checkbox\" id=\"multiSimCheckbox\">\n                Simulate Multiple Systems\n            </label>\n            <!-- Button next to the slider -->\n            <button id=\"but1\">Start/Pause</button>\n        </div>\n\n        <!-- Multi-sim checkboxes and submit button -->\n        <div class=\"multiSimControls\" id=\"multiSimControls\">\n            <div id=\"checkboxes\">\n                <!-- Checkboxes will be inserted here -->\n            </div>\n            <button id=\"submitBtn\">Submit</button>\n        </div>\n\n        <!-- Warning about CPU intensity -->\n        <div class=\"warning\">\n            Warning: Simulating multiple systems can be CPU intensive.\n        </div>\n    </div>\n    <canvas id=\"projectCanvas\"></canvas>\n\n    <script src=\"main.js\">\n        \n    </script>\n</body>\n</html>",
      "status": "",
      "output": "\n\n\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Lattice Boltzman Fluid Simulator</title>\n    <link href=\"https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&amp;display=swap\" rel=\"stylesheet\">\n    <style>\n        body {\n            margin: 0;\n            font-family: 'Roboto', sans-serif;\n            background-color: #121212;\n            color: #e0e0e0;\n        }\n        .container {\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n            justify-content: center;\n            height: 30vh;\n        }\n        .header {\n            margin-bottom: 20px;\n        }\n        h1 {\n            font-size: 2rem;\n            font-weight: 700;\n        }\n        .controls {\n            display: flex;\n            justify-content: center;\n            gap: 20px;\n            margin-bottom: 20px;\n            flex-wrap: wrap;  /* Allows wrapping */\n        }\n        .controls label {\n            font-weight: 500;\n        }\n        .controls select, .controls input {\n            background-color: #1e1e1e;\n            color: #e0e0e0;\n            border: 1px solid #333;\n            padding: 5px 10px;\n            border-radius: 5px;\n        }\n        button {\n            background-color: #333;\n            color: #e0e0e0;\n            padding: 10px 20px;\n            border: none;\n            border-radius: 5px;\n            cursor: pointer;\n        }\n        button:hover {\n            background-color: #444;\n        }\n        #projectCanvas {\n            width: 100%;\n            max-width: 100%;\n            height: 100%;\n            background-color: #000;\n            display: block;\n            margin: 0 auto;\n        }\n        .warning {\n            color: #ffcc00;\n            font-size: 0.9rem;\n            margin-top: 10px;\n            text-align: center;\n        }\n        button:disabled {\n            background-color: #555;\n            cursor: not-allowed;\n        }\n        .multiSimControls {\n            display: none;\n            flex-direction: column;\n            gap: 10px;\n            margin-top: 20px;\n        }\n    </style>\n\n\n    <div class=\"container\">\n        <div class=\"header\">\n            <h1>Lattice Boltzman Fluid Simulator</h1>\n        </div>\n        <div class=\"controls\">\n            <label for=\"plotOptions\">Plot: \n                <select id=\"plotOptions\">\n                    <option value=\"curl\">Curl</option>\n                    <option value=\"rho\">Density</option>\n                    <option value=\"speed\">Speed</option>\n                    <option value=\"vx\">X Velocity</option>\n                    <option value=\"vy\">Y Velocity</option>\n                </select>\n            </label>\n            <label for=\"viscositySlider\">Viscosity: \n                <input type=\"range\" id=\"viscositySlider\" min=\"0.003\" max=\"0.1\" step=\"0.001\" value=\"0.015\">\n            </label>\n            <!-- Checkbox for multi-simulation -->\n            <label for=\"multiSimCheckbox\">\n                <input type=\"checkbox\" id=\"multiSimCheckbox\">\n                Simulate Multiple Systems\n            </label>\n            <!-- Button next to the slider -->\n            <button id=\"but1\">Start/Pause</button>\n        </div>\n\n        <!-- Multi-sim checkboxes and submit button -->\n        <div class=\"multiSimControls\" id=\"multiSimControls\">\n            <div id=\"checkboxes\">\n                <!-- Checkboxes will be inserted here -->\n            </div>\n            <button id=\"submitBtn\">Submit</button>\n        </div>\n\n        <!-- Warning about CPU intensity -->\n        <div class=\"warning\">\n            Warning: Simulating multiple systems can be CPU intensive.\n        </div>\n    </div>\n    <canvas id=\"projectCanvas\" width=\"1920\" height=\"742\"></canvas>\n\n    <script src=\"main.js\">\n        \n    </script>\n\n",
      "type": "html"
    },
    {
      "code": "\"use strict\";\nonmessage = function (e) {\n    /*\n      let n0 = new Float32Array(new ArrayBuffer(height * width * Float32Array.BYTES_PER_ELEMENT))\n      let nN = new Float32Array(new ArrayBuffer(height * width * Float32Array.BYTES_PER_ELEMENT))\n      let nS = new Float32Array(new ArrayBuffer(height * width * Float32Array.BYTES_PER_ELEMENT))\n      let nE = new Float32Array(new ArrayBuffer(height * width * Float32Array.BYTES_PER_ELEMENT))\n      let nW = new Float32Array(new ArrayBuffer(height * width * Float32Array.BYTES_PER_ELEMENT))\n      let nNW = new Float32Array(new ArrayBuffer(height * width * Float32Array.BYTES_PER_ELEMENT))\n      let nNE = new Float32Array(new ArrayBuffer(height * width * Float32Array.BYTES_PER_ELEMENT))\n      let nSE = new Float32Array(new ArrayBuffer(height * width * Float32Array.BYTES_PER_ELEMENT))\n      let nSW = new Float32Array(new ArrayBuffer(height * width * Float32Array.BYTES_PER_ELEMENT))\n      \n      let bar = new Float32Array(new ArrayBuffer(height * width * Float32Array.BYTES_PER_ELEMENT))\n      \n      let rho = new Float32Array(new ArrayBuffer(height * width * Float32Array.BYTES_PER_ELEMENT))\n      let ux = new Float32Array(new ArrayBuffer(height * width * Float32Array.BYTES_PER_ELEMENT))\n      let uy = new Float32Array(new ArrayBuffer(height * width * Float32Array.BYTES_PER_ELEMENT))\n      let speed2 = new Float32Array(new ArrayBuffer(height * width * Float32Array.BYTES_PER_ELEMENT))\n      \n      */\n    const flatten2D = (i, j) => {\n        return j * width + i;\n    };\n    const D_Square = (x1, y1, x2, y2) => {\n        return ((x1 - x2) * (x1 - x2)) + ((y1 - y2) * (y1 - y2));\n    };\n    let animationFrameId = 0;\n    const four9ths = 4 / 9;\n    const one9th = 1 / 9;\n    const one36th = 1 / 36;\n    const { id, posId, viscosity, height, width, CALC_DRAW_RATIO, u0, n0, nN, nS, nE, nW, nNW, nNE, nSE, nSW, bar, rho, ux, uy, speed2, functionArguments } = e.data;\n    const omega = 1 / (3 * viscosity + 0.5);\n    const stream = () => {\n        // for x in range(0, width-1):\n        for (let x = 0; x < width - 1; x++) {\n            // for y in range(1, height-1):\n            for (let y = 1; y < height - 1; y++) {\n                nN[y * width + x] = nN[y * width + x + width];\n                nNW[y * width + x] = nNW[y * width + x + width + 1];\n                nW[y * width + x] = nW[y * width + x + 1];\n                nS[(height - y - 1) * width + x] = nS[(height - y - 1 - 1) * width + x];\n                nSW[(height - y - 1) * width + x] =\n                    nSW[(height - y - 1 - 1) * width + x + 1];\n                nE[y * width + (width - x - 1)] = nE[y * width + (width - (x + 1) - 1)];\n                nNE[y * width + (width - x - 1)] =\n                    nNE[y * width + width + (width - (x + 1) - 1)];\n                nSE[(height - y - 1) * width + (width - x - 1)] =\n                    nSE[(height - y - 1 - 1) * width + (width - (x + 1) - 1)];\n            }\n        }\n        const x = width;\n        // for y in range(1, height-1):\n        for (let y = 1; y < height - 1; y++) {\n            nN[y * width + x] = nN[y * width + x + width];\n            nS[(height - y - 1) * width + x] = nS[(height - y - 1 - 1) * width + x];\n        }\n    };\n    const bounce = () => {\n        // for x in range(2, width-2):\n        //     for y in range(2, height-2):\n        for (let x = 2; x < width - 2; x++) {\n            for (let y = 2; y < height - 2; y++) {\n                // if (bar[y*width + x]):\n                if (bar[y * width + x]) {\n                    //Barrier bounces the velocity back\n                    nN[(y - 1) * width + x] = nS[y * width + x];\n                    nS[(y + 1) * width + x] = nN[y * width + x];\n                    nE[y * width + x + 1] = nW[y * width + x];\n                    nW[y * width + (x - 1)] = nE[y * width + x];\n                    nNE[(y - 1) * width + (x + 1)] = nSW[y * width + x];\n                    nNW[(y - 1) * width + (x - 1)] = nSE[y * width + x];\n                    nSE[(y + 1) * width + (x + 1)] = nNW[y * width + x];\n                    nSW[(y + 1) * width + (x - 1)] = nNE[y * width + x];\n                    n0[y * width + x] = 0;\n                    nN[y * width + x] = 0;\n                    nS[y * width + x] = 0;\n                    nE[y * width + x] = 0;\n                    nW[y * width + x] = 0;\n                    nNE[y * width + x] = 0;\n                    nNW[y * width + x] = 0;\n                    nSE[y * width + x] = 0;\n                    nSW[y * width + x] = 0;\n                }\n            }\n        }\n    };\n    // def collide():\n    const collide = (om) => {\n        // for x in range(1, width-1):\n        //     for y in range(1, height-1):\n        for (let x = 1; x < width - 1; x++) {\n            for (let y = 1; y < height - 1; y++) {\n                let i = y * width + x;\n                // if (bar[i]):\n                //     continue\n                if (bar[i]) {\n                    continue;\n                }\n                else {\n                    rho[i] =\n                        n0[i] +\n                            nN[i] +\n                            nE[i] +\n                            nS[i] +\n                            nW[i] +\n                            nNE[i] +\n                            nSE[i] +\n                            nSW[i] +\n                            nNW[i];\n                    // if (rho[i] > 0):\n                    if (rho[i] > 0) {\n                        ux[i] =\n                            (nE[i] + nNE[i] + nSE[i] - nW[i] - nNW[i] - nSW[i]) *\n                                (1 - (rho[i] - 1) + (rho[i] - 1) ** 2);\n                        uy[i] =\n                            (nN[i] + nNE[i] + nNW[i] - nS[i] - nSE[i] - nSW[i]) *\n                                (1 - (rho[i] - 1) + (rho[i] - 1) ** 2);\n                    }\n                    // one9th_rho = one9th * rho[i]\n                    // one36th_rho = one36th * rho[i]\n                    // vx3 = 3 * ux[i]\n                    // vy3 = 3 * uy[i]\n                    // vx2 = ux[i] * ux[i]\n                    // vy2 = uy[i] * uy[i]\n                    // vxvy2 = 2 * ux[i] * uy[i]\n                    // v2 = vx2 + vy2\n                    // speed2[i] = v2\n                    // v215 = 1.5 * v2\n                    const one9th_rho = one9th * rho[i];\n                    const one36th_rho = one36th * rho[i];\n                    const vx3 = 3 * ux[i];\n                    const vy3 = 3 * uy[i];\n                    const vx2 = ux[i] * ux[i];\n                    const vy2 = uy[i] * uy[i];\n                    const vxvy2 = 2 * ux[i] * uy[i];\n                    const v2 = vx2 + vy2;\n                    speed2[i] = v2;\n                    const v215 = 1.5 * v2;\n                    nE[i] += om * (one9th_rho * (1 + vx3 + 4.5 * vx2 - v215) - nE[i]);\n                    nW[i] += om * (one9th_rho * (1 - vx3 + 4.5 * vx2 - v215) - nW[i]);\n                    nN[i] += om * (one9th_rho * (1 + vy3 + 4.5 * vy2 - v215) - nN[i]);\n                    nS[i] += om * (one9th_rho * (1 - vy3 + 4.5 * vy2 - v215) - nS[i]);\n                    nNE[i] +=\n                        om *\n                            (one36th_rho * (1 + vx3 + vy3 + 4.5 * (v2 + vxvy2) - v215) -\n                                nNE[i]);\n                    nNW[i] +=\n                        om *\n                            (one36th_rho * (1 - vx3 + vy3 + 4.5 * (v2 - vxvy2) - v215) -\n                                nNW[i]);\n                    nSE[i] +=\n                        om *\n                            (one36th_rho * (1 + vx3 - vy3 + 4.5 * (v2 - vxvy2) - v215) -\n                                nSE[i]);\n                    nSW[i] +=\n                        om *\n                            (one36th_rho * (1 - vx3 - vy3 + 4.5 * (v2 + vxvy2) - v215) -\n                                nSW[i]);\n                    n0[i] =\n                        rho[i] -\n                            (nE[i] + nW[i] + nN[i] + nS[i] + nNE[i] + nSE[i] + nNW[i] + nSW[i]);\n                }\n            }\n        }\n    };\n    const initialize = (u0 = 0.1) => {\n        let xcoord = 0;\n        let ycoord = 0;\n        for (let i = 0; i < height * width; i++) {\n            n0[i] = four9ths * (1 - 1.5 * u0 ** 2);\n            nN[i] = one9th * (1 - 1.5 * u0 ** 2);\n            nS[i] = one9th * (1 - 1.5 * u0 ** 2);\n            nE[i] = one9th * (1 + 3 * u0 + 4.5 * u0 ** 2 - 1.5 * u0 ** 2);\n            nW[i] = one9th * (1 - 3 * u0 + 4.5 * u0 ** 2 - 1.5 * u0 ** 2);\n            nNE[i] = one36th * (1 + 3 * u0 + 4.5 * u0 ** 2 - 1.5 * u0 ** 2);\n            nSE[i] = one36th * (1 + 3 * u0 + 4.5 * u0 ** 2 - 1.5 * u0 ** 2);\n            nNW[i] = one36th * (1 - 3 * u0 + 4.5 * u0 ** 2 - 1.5 * u0 ** 2);\n            nSW[i] = one36th * (1 - 3 * u0 + 4.5 * u0 ** 2 - 1.5 * u0 ** 2);\n            rho[i] =\n                n0[i] +\n                    nN[i] +\n                    nS[i] +\n                    nE[i] +\n                    nW[i] +\n                    nNE[i] +\n                    nSE[i] +\n                    nNW[i] +\n                    nSW[i];\n            ux[i] =\n                (nE[i] + nNE[i] + nSE[i] - nW[i] - nNW[i] - nSW[i]) *\n                    (1 - (rho[i] - 1) + (rho[i] - 1) ** 2);\n            uy[i] =\n                (nN[i] + nNE[i] + nNW[i] - nS[i] - nSE[i] - nSW[i]) *\n                    (1 - (rho[i] - 1) + (rho[i] - 1) ** 2);\n            xcoord = xcoord + 1 < width - 1 ? xcoord + 1 : 0;\n            ycoord = xcoord != 0 ? ycoord : ycoord + 1;\n        }\n    };\n    const createWall = (x, y) => {\n        bar[flatten2D(x, y)] = 1;\n    };\n    const removeWall = (x, y) => {\n        bar[flatten2D(x, y)] = 0;\n    };\n    initialize(u0);\n    const drawBlock = (Block_Height, Block_width, pos_X_block, pos_Y_block) => {\n        for (let i = pos_X_block; i < pos_X_block + Block_width; i++) {\n            for (let j = Math.floor(Math.abs(pos_Y_block - Block_Height / 2)) - 1; j < pos_Y_block + Block_Height / 2; j++) {\n                createWall(i, j);\n            }\n        }\n    };\n    const drawCircleBarrier = (radius, pos_X, pos_Y) => {\n        for (let i = 0; i < width; i++) {\n            for (let j = 0; j < height; j++) {\n                if ((D_Square(i, j, pos_X, pos_Y)) <= radius ** 2 - 0.001) {\n                    createWall(i, j);\n                }\n            }\n        }\n    };\n    // drawCircleBarrier(5, 60)\n    // drawCircleBarrier(7,90)\n    // creat ramp but ..\n    const drawramp = (ramp_H, pos_X_ramp, pos_Y_ramp) => {\n        for (let i = pos_X_ramp; i < ramp_H + pos_X_ramp; i++) {\n            for (let j = pos_Y_ramp; j < i + pos_Y_ramp - pos_X_ramp; j++) {\n                createWall(i, j);\n            }\n        }\n        for (let i = pos_X_ramp; i < pos_X_ramp + ramp_H; i++) {\n            for (let j = pos_Y_ramp; j > pos_Y_ramp - i + pos_X_ramp; j--) {\n                createWall(i, j);\n            }\n        }\n    };\n    // creat invertedramp \n    const drawinvertedramp = (ramp_H, pos_X_ramp, pos_Y_ramp) => {\n        for (let i = ramp_H + pos_X_ramp; i >= pos_X_ramp; i--) {\n            for (let j = ramp_H - i + pos_Y_ramp + pos_X_ramp; j > pos_Y_ramp; j--) {\n                createWall(i, j);\n            }\n        }\n        for (let i = pos_X_ramp; i < pos_X_ramp + ramp_H; i++) {\n            for (let j = pos_Y_ramp - ramp_H + (i - pos_X_ramp); j <= pos_Y_ramp; j++) {\n                createWall(i, j);\n            }\n        }\n    };\n    // creat invertedramp but for Pacman..\n    const drawinvertedramp1 = (ramp_H, pos_X_ramp, pos_Y_ramp) => {\n        for (let i = ramp_H + pos_X_ramp; i >= pos_X_ramp; i--) {\n            for (let j = ramp_H - i + pos_Y_ramp + pos_X_ramp; j > pos_Y_ramp; j--) {\n                removeWall(i, j);\n            }\n        }\n        for (let i = pos_X_ramp; i < pos_X_ramp + ramp_H; i++) {\n            for (let j = pos_Y_ramp - ramp_H + (i - pos_X_ramp); j <= pos_Y_ramp; j++) {\n                removeWall(i, j);\n            }\n        }\n    };\n    const drawPacman = () => {\n        drawCircleBarrier(10, 35, 50);\n        drawinvertedramp1(8, 25, 50);\n    };\n    // drawBlock(5, 15, 25, 25);\n    const drawId = (k) => {\n        if (k == 10) {\n            drawBlock(15, 1, 20, 42);\n        }\n        ;\n        if (k == 2) {\n            drawBlock(10, 20, 20, 45);\n        }\n        ;\n        if (k == 3) {\n            drawBlock(20, 7, 20, 40);\n        }\n        ;\n        if (k == 4) {\n            drawCircleBarrier(3, 25, 50);\n        }\n        if (k == 5) {\n            drawCircleBarrier(8, 25, 50);\n        }\n        if (k == 6) {\n            drawCircleBarrier(8, 25, 50);\n            drawCircleBarrier(5, 32, 50);\n            drawCircleBarrier(3, 39, 50);\n        }\n        if (k == 7) {\n            drawramp(8, 20, 50);\n        }\n        if (k == 8) {\n            drawramp(10, 25, 50);\n            drawramp(5, 35, 50);\n            drawramp(3, 40, 50);\n        }\n        if (k == 9) {\n            drawinvertedramp(8, 30, 50);\n        }\n        if (k == 1) {\n            drawPacman();\n        }\n    };\n    drawId(e.data.id);\n    let j = 1;\n    let isAnimating = false;\n    const tick = (om) => {\n        if (!isAnimating) {\n            isAnimating = true;\n            animationFrameId = requestAnimationFrame(() => tick(om)); // start the loop\n        }\n        stream();\n        bounce();\n        collide(om);\n        if (j % CALC_DRAW_RATIO == 0) {\n            postMessage({ posId, rho, ux, uy, speed2 });\n        }\n        // console.log(j, om);\n        j++;\n        isAnimating = false;\n    };\n    tick(omega);\n};\n",
      "status": "[10]<br><span style=\"font-size:8px\">2ms<span></span></span>",
      "output": "<p class=\"error\">Object too large to show.</p><br>",
      "type": "code"
    },
    {
      "code": "\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nconst canvas = document.getElementById(\"projectCanvas\");\nconst NoOfWorkers = 10;\ncanvas.width = window.innerWidth * devicePixelRatio;\ncanvas.height = window.innerHeight * devicePixelRatio;\nconst ctx = canvas.getContext(\"2d\");\nconst height = 100;\nconst width = 200;\nconst multiplier = 1.5;\nlet viscosity = 0.01 * multiplier;\nlet omega = 1 / (3 * viscosity + 0.5);\nconst u0 = 0.2 / multiplier;\nconst four9ths = 4. / 9.;\nconst one9th = 1. / 9.;\nconst one36th = 1. / 36.;\nconst CALC_DRAW_RATIO = 10;\nconst DRAW_SCALE_X = 1 * canvas.width / width;\nconst maxSpeed = 0.4;\nconst functionArguments = new Float32Array(5);\nlet n0 = new Float32Array(new ArrayBuffer(height * width * Float32Array.BYTES_PER_ELEMENT));\nlet nN = new Float32Array(new ArrayBuffer(height * width * Float32Array.BYTES_PER_ELEMENT));\nlet nS = new Float32Array(new ArrayBuffer(height * width * Float32Array.BYTES_PER_ELEMENT));\nlet nE = new Float32Array(new ArrayBuffer(height * width * Float32Array.BYTES_PER_ELEMENT));\nlet nW = new Float32Array(new ArrayBuffer(height * width * Float32Array.BYTES_PER_ELEMENT));\nlet nNW = new Float32Array(new ArrayBuffer(height * width * Float32Array.BYTES_PER_ELEMENT));\nlet nNE = new Float32Array(new ArrayBuffer(height * width * Float32Array.BYTES_PER_ELEMENT));\nlet nSE = new Float32Array(new ArrayBuffer(height * width * Float32Array.BYTES_PER_ELEMENT));\nlet nSW = new Float32Array(new ArrayBuffer(height * width * Float32Array.BYTES_PER_ELEMENT));\nlet bar = new Float32Array(new ArrayBuffer(height * width * Float32Array.BYTES_PER_ELEMENT));\nlet rho = new Float32Array(new ArrayBuffer(height * width * Float32Array.BYTES_PER_ELEMENT));\nlet ux = new Float32Array(new ArrayBuffer(height * width * Float32Array.BYTES_PER_ELEMENT));\nlet uy = new Float32Array(new ArrayBuffer(height * width * Float32Array.BYTES_PER_ELEMENT));\nlet speed2 = new Float32Array(new ArrayBuffer(height * width * Float32Array.BYTES_PER_ELEMENT));\nlet plotOption = \"curl\";\nconst plotSelect = document.getElementById(\"plotOptions\");\n// Add an event listener to detect changes in the dropdown\nplotSelect.addEventListener(\"change\", () => {\n    // Update the PlotOption variable to the selected value\n    plotOption = plotSelect.value;\n});\nlet paused = false;\nlet animVal = 0;\nconst playPauseButton = document.getElementById(\"but1\");\nplayPauseButton.addEventListener(\"click\", () => {\n    paused = !paused; // Toggle the paused state\n    if (!paused) {\n        // Resume the animation\n        tick();\n    }\n    else {\n        // Pause the animation by canceling the next frame\n        if (animVal !== null) {\n            cancelAnimationFrame(animVal);\n        }\n    }\n});\nconst flatten2D = (i, j) => {\n    return j * width + i;\n};\nconst D_Square = (x1, y1, x2, y2) => {\n    return ((x1 - x2) * (x1 - x2)) + ((y1 - y2) * (y1 - y2));\n};\nconst stream = () => {\n    // for x in range(0, width-1):\n    for (let x = 0; x < width - 1; x++) {\n        // for y in range(1, height-1):\n        for (let y = 1; y < height - 1; y++) {\n            nN[y * width + x] = nN[y * width + x + width];\n            nNW[y * width + x] = nNW[y * width + x + width + 1];\n            nW[y * width + x] = nW[y * width + x + 1];\n            nS[(height - y - 1) * width + x] = nS[(height - y - 1 - 1) * width + x];\n            nSW[(height - y - 1) * width + x] = nSW[(height - y - 1 - 1) * width + x + 1];\n            nE[y * width + (width - x - 1)] = nE[y * width + (width - (x + 1) - 1)];\n            nNE[y * width + (width - x - 1)] = nNE[y * width + width + (width - (x + 1) - 1)];\n            nSE[(height - y - 1) * width + (width - x - 1)] = nSE[(height - y - 1 - 1) * width +\n                (width - (x + 1) - 1)];\n        }\n    }\n    const x = width;\n    // for y in range(1, height-1):\n    for (let y = 1; y < height - 1; y++) {\n        nN[y * width + x] = nN[y * width + x + width];\n        nS[(height - y - 1) * width + x] = nS[(height - y - 1 - 1) * width + x];\n    }\n};\nconst ensureStability = () => {\n    for (let i = 0; i < height * width; i++) {\n        n0[i] = n0[1] > maxSpeed ? maxSpeed : n0[i];\n        nN[i] = nN[1] > maxSpeed ? maxSpeed : nN[i];\n        nS[i] = nS[1] > maxSpeed ? maxSpeed : nS[i];\n        nE[i] = nE[1] > maxSpeed ? maxSpeed : nE[i];\n        nW[i] = nW[1] > maxSpeed ? maxSpeed : nW[i];\n        nNE[i] = nNE[1] > maxSpeed ? maxSpeed : nNE[i];\n        nNW[i] = nNW[1] > maxSpeed ? maxSpeed : nNW[i];\n        nSE[i] = nSE[1] > maxSpeed ? maxSpeed : nSE[i];\n        nSW[i] = nSW[1] > maxSpeed ? maxSpeed : nSW[i];\n    }\n};\nconst bounce = () => {\n    // for x in range(2, width-2):\n    //     for y in range(2, height-2):\n    for (let x = 2; x < width - 2; x++) {\n        for (let y = 2; y < height - 2; y++) {\n            // if (bar[y*width + x]):\n            if (bar[y * width + x]) {\n                //Barrier bounces the velocity back\n                nN[(y - 1) * width + x] = nS[y * width + x];\n                nS[(y + 1) * width + x] = nN[y * width + x];\n                nE[y * width + x + 1] = nW[y * width + x];\n                nW[y * width + (x - 1)] = nE[y * width + x];\n                nNE[(y - 1) * width + (x + 1)] = nSW[y * width + x];\n                nNW[(y - 1) * width + (x - 1)] = nSE[y * width + x];\n                nSE[(y + 1) * width + (x + 1)] = nNW[y * width + x];\n                nSW[(y + 1) * width + (x - 1)] = nNE[y * width + x];\n                n0[y * width + x] = 0;\n                nN[y * width + x] = 0;\n                nS[y * width + x] = 0;\n                nE[y * width + x] = 0;\n                nW[y * width + x] = 0;\n                nNE[y * width + x] = 0;\n                nNW[y * width + x] = 0;\n                nSE[y * width + x] = 0;\n                nSW[y * width + x] = 0;\n            }\n        }\n    }\n};\n// def collide():\nconst collide = () => {\n    // for x in range(1, width-1):\n    //     for y in range(1, height-1):\n    for (let x = 1; x < width - 1; x++) {\n        for (let y = 1; y < height - 1; y++) {\n            let i = y * width + x;\n            // if (bar[i]):\n            //     continue\n            if (bar[i]) {\n                continue;\n            }\n            else {\n                rho[i] = n0[i] + nN[i] + nE[i] + nS[i] + nW[i] + nNE[i] + nSE[i] + nSW[i] + nNW[i];\n                // if (rho[i] > 0):\n                if (rho[i] > 0) {\n                    ux[i] = (nE[i] + nNE[i] + nSE[i] - nW[i] - nNW[i] - nSW[i]) * (1 - (rho[i] - 1) + ((rho[i] - 1) ** 2.));\n                    uy[i] = (nN[i] + nNE[i] + nNW[i] - nS[i] - nSE[i] - nSW[i]) * (1 - (rho[i] - 1) + ((rho[i] - 1) ** 2.));\n                }\n                // one9th_rho = one9th * rho[i]\n                // one36th_rho = one36th * rho[i]\n                // vx3 = 3 * ux[i]\n                // vy3 = 3 * uy[i]\n                // vx2 = ux[i] * ux[i]\n                // vy2 = uy[i] * uy[i]\n                // vxvy2 = 2 * ux[i] * uy[i]\n                // v2 = vx2 + vy2\n                // speed2[i] = v2\n                // v215 = 1.5 * v2\n                const one9th_rho = one9th * rho[i];\n                const one36th_rho = one36th * rho[i];\n                const vx3 = 3 * ux[i];\n                const vy3 = 3 * uy[i];\n                const vx2 = ux[i] * ux[i];\n                const vy2 = uy[i] * uy[i];\n                const vxvy2 = 2 * ux[i] * uy[i];\n                const v2 = vx2 + vy2;\n                speed2[i] = v2;\n                const v215 = 1.5 * v2;\n                nE[i] += omega * (one9th_rho * (1 + vx3 + 4.5 * vx2 - v215) - nE[i]);\n                nW[i] += omega * (one9th_rho * (1 - vx3 + 4.5 * vx2 - v215) - nW[i]);\n                nN[i] += omega * (one9th_rho * (1 + vy3 + 4.5 * vy2 - v215) - nN[i]);\n                nS[i] += omega * (one9th_rho * (1 - vy3 + 4.5 * vy2 - v215) - nS[i]);\n                nNE[i] += omega * (one36th_rho * (1 + vx3 + vy3 + 4.5 * (v2 + vxvy2) - v215) - nNE[i]);\n                nNW[i] += omega * (one36th_rho * (1 - vx3 + vy3 + 4.5 * (v2 - vxvy2) - v215) - nNW[i]);\n                nSE[i] += omega * (one36th_rho * (1 + vx3 - vy3 + 4.5 * (v2 - vxvy2) - v215) - nSE[i]);\n                nSW[i] += omega * (one36th_rho * (1 - vx3 - vy3 + 4.5 * (v2 + vxvy2) - v215) - nSW[i]);\n                n0[i] = rho[i] - (nE[i] + nW[i] + nN[i] + nS[i] + nNE[i] + nSE[i] + nNW[i] + nSW[i]);\n            }\n        }\n    }\n};\n// def initialize(xtop, ytop, yheight, u0=u0):\n//     xcoord = 0\n//     ycoord = 0\n//     count = 0\n//     for i in range(height*width):\n//         n0[i] = four9ths* (1 - 1.5*(u0**2.))\n//         nN[i] = one9th  * (1 - 1.5*(u0**2.))\n//         nS[i] = one9th  * (1 - 1.5*(u0**2.))\n//         nE[i] = one9th  * (1 + 3*u0 + 4.5*(u0**2.) - 1.5*(u0**2.))\n//         nW[i] = one9th  * (1 - 3*u0 + 4.5*(u0**2.) - 1.5*(u0**2.))\n//         nNE[i]= one36th * (1 + 3*u0 + 4.5*(u0**2.) - 1.5*(u0**2.))\n//         nSE[i]= one36th * (1 + 3*u0 + 4.5*(u0**2.) - 1.5*(u0**2.))\n//         nNW[i]= one36th * (1 - 3*u0 + 4.5*(u0**2.) - 1.5*(u0**2.))\n//         nSW[i]= one36th * (1 - 3*u0 + 4.5*(u0**2.) - 1.5*(u0**2.))\n//         rho[i] =  n0[i] + nN[i] + nS[i] + nE[i] + nW[i] + nNE[i] + nSE[i] + nNW[i] + nSW[i]\n//         ux[i]  = (nE[i] + nNE[i] + nSE[i] - nW[i] - nNW[i] - nSW[i]) * (1-(rho[i]-1)+((rho[i]-1)**2.))\n//         uy[i]  = (nN[i] + nNE[i] + nNW[i] - nS[i] - nSE[i] - nSW[i]) * (1-(rho[i]-1)+((rho[i]-1)**2.))\n//         if (xcoord==xtop):\n//             if (ycoord >= ytop):\n//                 if (ycoord < (ytop+yheight)):\n//                     count += 1\n//                     bar[ycoord*width + xcoord] = 1\n//         xcoord = (xcoord+1) if xcoord<(width-1) else 0\n//         ycoord = ycoord if (xcoord != 0) else (ycoord + 1)\nconst initialize = (u0 = 0.1) => {\n    let xcoord = 0;\n    let ycoord = 0;\n    for (let i = 0; i < height * width; i++) {\n        n0[i] = four9ths * (1 - 1.5 * (u0 ** 2.));\n        nN[i] = one9th * (1 - 1.5 * (u0 ** 2.));\n        nS[i] = one9th * (1 - 1.5 * (u0 ** 2.));\n        nE[i] = one9th * (1 + 3 * u0 + 4.5 * (u0 ** 2.) - 1.5 * (u0 ** 2.));\n        nW[i] = one9th * (1 - 3 * u0 + 4.5 * (u0 ** 2.) - 1.5 * (u0 ** 2.));\n        nNE[i] = one36th * (1 + 3 * u0 + 4.5 * (u0 ** 2.) - 1.5 * (u0 ** 2.));\n        nSE[i] = one36th * (1 + 3 * u0 + 4.5 * (u0 ** 2.) - 1.5 * (u0 ** 2.));\n        nNW[i] = one36th * (1 - 3 * u0 + 4.5 * (u0 ** 2.) - 1.5 * (u0 ** 2.));\n        nSW[i] = one36th * (1 - 3 * u0 + 4.5 * (u0 ** 2.) - 1.5 * (u0 ** 2.));\n        rho[i] = n0[i] + nN[i] + nS[i] + nE[i] + nW[i] + nNE[i] + nSE[i] + nNW[i] + nSW[i];\n        ux[i] = (nE[i] + nNE[i] + nSE[i] - nW[i] - nNW[i] - nSW[i]) * (1 - (rho[i] - 1) + ((rho[i] - 1) ** 2.));\n        uy[i] = (nN[i] + nNE[i] + nNW[i] - nS[i] - nSE[i] - nSW[i]) * (1 - (rho[i] - 1) + ((rho[i] - 1) ** 2.));\n        xcoord = (xcoord + 1) < (width - 1) ? xcoord + 1 : 0;\n        ycoord = xcoord != 0 ? ycoord : ycoord + 1;\n    }\n};\nconst createWall = (x, y) => {\n    bar[flatten2D(x, y)] = 1;\n};\nconst removeWall = (x, y) => {\n    bar[flatten2D(x, y)] = 0;\n};\nconst handleBoundaries = () => {\n};\nconst offsetX = (canvas.width - width * DRAW_SCALE_X) / 2;\n// const offsetY = (canvas.height - height * DRAW_SCALE_X) / 2;\nconst offsetY = 0;\nconst draw = (id, rho, ux, uy, speed2) => {\n    //   ctx.clearRect(0, 0, canvas.width, canvas.height);\n    const actualOffset = offsetY + id * height * DRAW_SCALE_X;\n    for (let x = 2; x < width - 2; x++) {\n        for (let y = 2; y < height - 10; y++) {\n            const i = y * width + x;\n            if (bar[i]) {\n                ctx.fillStyle = \"black\";\n                ctx.fillRect(offsetX + x * DRAW_SCALE_X, actualOffset + y * DRAW_SCALE_X, DRAW_SCALE_X, DRAW_SCALE_X);\n            }\n            else {\n                let c = 0;\n                switch (plotOption) {\n                    case \"rho\":\n                        c = 1 * Math.floor(200 * (rho[i] ** 6));\n                        ctx.fillStyle = `rgb(${c}, ${c}, ${c})`;\n                        break;\n                    case \"vx\":\n                        c = 10 * Math.floor(255 * ux[i]);\n                        ctx.fillStyle = `rgb(${0}, ${c}, ${c})`;\n                        break;\n                    case \"vy\":\n                        c = 10 * Math.floor(255 * uy[i]);\n                        ctx.fillStyle = `rgb(${125 + c}, ${125 + c}, ${0})`;\n                        break;\n                    case \"speed\":\n                        c = 5 * Math.floor(255 * Math.sqrt(speed2[i]));\n                        ctx.fillStyle = `rgb(${c}, ${c}, ${c})`;\n                        break;\n                    case \"curl\":\n                        c = 15 * Math.floor(255 * (uy[x + 1 + y * width] - uy[x - 1 + y * width] - ux[x + (y + 1) * width] + ux[x + (y - 1) * width]));\n                        ctx.fillStyle = `rgb(${Math.max(0, c)}, ${0}, ${Math.max(0, -c)})`;\n                        break;\n                }\n                // const c = 3000 * (uy[x + 1 + y * width] - uy[x - 1 + y * width] - ux[x + (y + 1) * width] + ux[x + (y - 1) * width]);\n                // ctx.fillStyle = `rgb(${Math.max(0, c)}, ${0}, ${Math.max(0, -c)})`;\n                ctx.fillRect(offsetX + x * DRAW_SCALE_X, actualOffset + y * DRAW_SCALE_X, DRAW_SCALE_X, DRAW_SCALE_X);\n            }\n        }\n    }\n};\nlet time = performance.now();\nlet iterationCounter = 0;\nconst tick = () => {\n    if (paused) {\n        return;\n    }\n    for (let iter = 0; iter < CALC_DRAW_RATIO; iter++) {\n        stream();\n        bounce();\n        collide();\n    }\n    // ensureStability()   \n    draw(0, rho, ux, uy, speed2);\n    animVal = requestAnimationFrame(tick);\n    const newTime = performance.now();\n    time = newTime;\n};\ninitialize(u0);\nconst drawBlock = (Block_Height, Block_width, pos_X_block, pos_Y_block) => {\n    for (let i = pos_X_block; i < pos_X_block + Block_width; i++) {\n        for (let j = Math.floor(Math.abs((pos_Y_block) - Block_Height / 2)) - 1; j < (pos_Y_block) + Block_Height / 2; j++) {\n            createWall(i, j);\n        }\n    }\n};\n// drawBlock(5,15,25,25)\n//creat Circle\nconst drawCircleBarrier = (radius, pos_X) => {\n    const pos_Y = Math.floor(height / 2);\n    for (let i = 0; i < width; i++) {\n        for (let j = 0; j < height; j++) {\n            if ((D_Square(i, j, pos_X, pos_Y)) <= radius ** 2 - 0.001) {\n                createWall(i, j);\n            }\n        }\n    }\n};\n// drawCircleBarrier(5, 60)\n// drawCircleBarrier(7,90)\n// creat ramp but ..\nconst drawramp = (ramp_H, pos_X_ramp, pos_Y_ramp) => {\n    for (let i = pos_X_ramp; i < ramp_H + pos_X_ramp; i++) {\n        for (let j = pos_Y_ramp; j < i + pos_Y_ramp - pos_X_ramp; j++) {\n            createWall(i, j);\n        }\n    }\n    for (let i = pos_X_ramp; i < pos_X_ramp + ramp_H; i++) {\n        for (let j = pos_Y_ramp; j > pos_Y_ramp - i + pos_X_ramp; j--) {\n            createWall(i, j);\n        }\n    }\n};\n// creat invertedramp but ..\nconst drawinvertedramp = (ramp_H, pos_X_ramp, pos_Y_ramp) => {\n    for (let i = ramp_H + pos_X_ramp; i >= pos_X_ramp; i--) {\n        for (let j = ramp_H - i + pos_Y_ramp + pos_X_ramp; j > pos_Y_ramp; j--) {\n            removeWall(i, j);\n        }\n    }\n    for (let i = pos_X_ramp; i < pos_X_ramp + ramp_H; i++) {\n        for (let j = pos_Y_ramp - ramp_H + (i - pos_X_ramp); j <= pos_Y_ramp; j++) {\n            removeWall(i, j);\n        }\n    }\n};\ndrawCircleBarrier(10, 35);\n// drawinvertedramp(8,25,50)\nlet isDrawing = false;\nconst getMousePosition = (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const posX = Math.floor((e.clientX - rect.left - offsetX) * width / (rect.width - 2 * offsetX));\n    const posY = Math.floor((e.clientY - rect.top - offsetY) * height / (rect.height - 2 * offsetY));\n    return { posX, posY };\n};\ncanvas.addEventListener(\"mousedown\", (e) => {\n    isDrawing = true;\n    const { posX, posY } = getMousePosition(e);\n    if (multiSimCHeckbox.checked) {\n        return;\n    }\n    if (posX >= 2 && posX < width - 2 && posY >= 2 && posY < height - 10) {\n        createWall(posX, posY);\n    }\n});\ncanvas.addEventListener(\"mousemove\", (e) => {\n    if (!isDrawing)\n        return; //\n    if (multiSimCHeckbox.checked) {\n        return;\n    }\n    const { posX, posY } = getMousePosition(e);\n    if (posX >= 2 && posX < width - 2 && posY >= 2 && posY < height - 10) {\n        createWall(posX, posY);\n        createWall(posX + 1, posY);\n        createWall(posX - 1, posY);\n        createWall(posX, posY + 1);\n        createWall(posX, posY - 1);\n        createWall(posX + 1, posY + 1);\n        createWall(posX - 1, posY - 1);\n        createWall(posX + 1, posY - 1);\n        createWall(posX - 1, posY + 1);\n    }\n});\ncanvas.addEventListener(\"mouseup\", () => {\n    isDrawing = false;\n});\ncanvas.addEventListener(\"mouseleave\", () => {\n    isDrawing = false;\n});\nconsole.log();\n// drawCircleBarrier(7,90)\"Initialization took\", performance.now()-time, \"ms\")\ntime = performance.now();\n// tick()\nlet workers = [];\n// Start the loop from i = 0 so workers are correctly pushed into the array.\nfor (let i = 0; i < NoOfWorkers; i++) {\n    workers.push(new Worker(\"worker1.js\"));\n}\nconst setup = () => __awaiter(void 0, void 0, void 0, function* () {\n    // Send messages to all workers, including worker1 and worker2\n    for (let i = 0; i < NoOfWorkers; i++) {\n        workers[i].postMessage({\n            messageType: \"initialize\",\n            id: i,\n            viscosity,\n            height,\n            width,\n            CALC_DRAW_RATIO,\n            u0, n0, nN, nS, nE, nW,\n            nNE, nNW, nSE, nSW,\n            bar, rho, ux, uy, speed2, functionArguments\n        });\n        yield new Promise((resolve) => setTimeout(resolve, 50));\n    }\n});\nconst constUpdateViscosity = () => {\n    for (let i = 0; i < NoOfWorkers; i++) {\n        workers[i].postMessage({\n            messageType: \"updateViscosity\",\n            viscosity\n        });\n    }\n};\n// Attach the onmessage handler for each worker in the array\nfor (let i = 0; i < NoOfWorkers; i++) {\n    workers[i].onmessage = (e) => {\n        draw(e.data.id, e.data.rho, e.data.ux, e.data.uy, e.data.speed2);\n    };\n}\nlet IDsToUse = [];\nconst viscositySlider = document.getElementById(\"viscositySlider\");\nconst multiSimCHeckbox = document.getElementById(\"multiSimCheckbox\");\nconst multiSimControls = document.getElementById('multiSimControls');\nconst checkboxesContainer = document.getElementById('checkboxes');\nconst submitBtn = document.getElementById('submitBtn');\nmultiSimCHeckbox.addEventListener(\"change\", function () {\n    // If the checkbox is checked, disable the viscosity slider\n    if (this.checked) {\n        cancelAnimationFrame(animVal);\n        bar = new Float32Array(new ArrayBuffer(height * width * Float32Array.BYTES_PER_ELEMENT));\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        viscositySlider.disabled = true;\n        playPauseButton.disabled = true;\n        multiSimControls.style.display = 'flex';\n        // Create checkboxes dynamically\n        checkboxesContainer.innerHTML = ''; // Clear previous checkboxes if any\n        for (let i = 1; i <= 10; i++) {\n            const checkboxWrapper = document.createElement('div');\n            const checkbox = document.createElement('input');\n            checkbox.type = 'checkbox';\n            checkbox.id = `${i}`;\n            const label = document.createElement('label');\n            label.setAttribute('for', checkbox.id);\n            // label.textContent = `name${i}`;\n            if (i === 1) {\n                label.textContent = `Pacman`;\n            }\n            if (i === 2) {\n                label.textContent = `Horizontal Rectangle`;\n            }\n            if (i === 3) {\n                label.textContent = `Vertical Rectangle`;\n            }\n            if (i === 4) {\n                label.textContent = `Small Circle`;\n            }\n            if (i === 5) {\n                label.textContent = `Big Circle`;\n            }\n            if (i === 6) {\n                label.textContent = `Multi Bump`;\n            }\n            if (i === 7) {\n                label.textContent = `Ramp`;\n            }\n            if (i === 8) {\n                label.textContent = `Multi Ramp`;\n            }\n            if (i === 9) {\n                label.textContent = `Inverted Ramp`;\n            }\n            if (i === 10) {\n                label.textContent = `Vertical Line`;\n            }\n            checkboxWrapper.appendChild(checkbox);\n            checkboxWrapper.appendChild(label);\n            checkboxesContainer.appendChild(checkboxWrapper);\n        }\n        for (let i = 0; i < workers.length; i++) {\n            workers[i].terminate();\n        }\n        for (let i = 0; i < IDsToUse.length; i++) {\n            workers.push(new Worker(\"worker1.js\"));\n            workers[i].postMessage({\n                messageType: \"initialize\",\n                posId: i,\n                id: IDsToUse[i],\n                viscosity,\n                height,\n                width,\n                CALC_DRAW_RATIO,\n                u0, n0, nN, nS, nE, nW,\n                nNE, nNW, nSE, nSW,\n                bar, rho, ux, uy, speed2\n            });\n        }\n    }\n    else {\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        for (let i = 0; i < workers.length; i++) {\n            workers[i].terminate();\n        }\n        canvas.height = window.innerHeight * devicePixelRatio;\n        viscositySlider.disabled = false;\n        playPauseButton.disabled = false;\n        multiSimControls.style.display = 'none';\n        drawCircleBarrier(10, 35);\n        tick();\n    }\n});\nconst createWebWorkerSims = (IDsToUse) => {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    canvas.height = window.innerHeight * devicePixelRatio * IDsToUse.length * 1.5;\n    for (let i = 0; i < workers.length; i++) {\n        workers[i].terminate();\n    }\n    workers = [];\n    for (let i = 0; i < IDsToUse.length; i++) {\n        workers.push(new Worker(\"worker1.js\"));\n    }\n    for (let i = 0; i < IDsToUse.length; i++) {\n        workers[i].postMessage({\n            messageType: \"initialize\",\n            posId: i,\n            id: IDsToUse[i],\n            viscosity,\n            height,\n            width,\n            CALC_DRAW_RATIO,\n            u0, n0, nN, nS, nE, nW,\n            nNE, nNW, nSE, nSW,\n            bar, rho, ux, uy, speed2\n        });\n    }\n    for (let i = 0; i < workers.length; i++) {\n        workers[i].onmessage = (e) => {\n            draw(e.data.posId, e.data.rho, e.data.ux, e.data.uy, e.data.speed2);\n        };\n    }\n};\n// Handle form submission\nsubmitBtn.addEventListener('click', () => {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    cancelAnimationFrame(animVal);\n    console.log('Submit button clicked');\n    IDsToUse = [];\n    const checkboxes = checkboxesContainer.querySelectorAll('input[type=\"checkbox\"]:checked');\n    checkboxes.forEach(checkbox => {\n        IDsToUse.push(parseInt(checkbox.id)); // Push the checked checkbox's id\n    });\n    console.log('Selected IDs:', IDsToUse);\n    canvas.height = window.innerHeight * devicePixelRatio * IDsToUse.length;\n    createWebWorkerSims(IDsToUse);\n});\nviscositySlider.addEventListener(\"input\", () => {\n    // Update the viscosity variable to the slider's current value\n    viscosity = parseFloat(viscositySlider.value) * multiplier;\n    omega = 1 / (3 * viscosity + 0.5);\n    // for (let i = 0; i < NoOfWorkers; i++) {\n    //     workers[i].postMessage({\n    //         messageType: \"updateViscosity\",\n    //         viscosity\n    //     });\n    // }\n    // console.log(`Viscosity updated to: ${viscosity}`);\n});\ntick();\n// setup()\n// workers = []\n// for (let i = 0; i < NoOfWorkers; i++) {\n//     workers[i].terminate();\n// }\n",
      "status": "[11]<br><span style=\"font-size:8px\">30ms<span></span></span>",
      "output": "",
      "type": "code"
    }
  ],
  "source": "https://github.com/gopi-suvanam/scribbler",
  "run_on_load": false
}